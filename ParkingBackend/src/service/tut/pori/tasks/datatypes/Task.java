/**
 * Copyright 2016 Tampere University of Technology, Pori Department
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package service.tut.pori.tasks.datatypes;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Set;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlElementRef;
import javax.xml.bind.annotation.XmlElementWrapper;
import javax.xml.bind.annotation.XmlEnum;
import javax.xml.bind.annotation.XmlEnumValue;
import javax.xml.bind.annotation.XmlRootElement;
import javax.xml.bind.annotation.XmlType;
import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;

import org.quartz.JobBuilder;

import service.tut.pori.tasks.Definitions;
import service.tut.pori.tasks.TaskDAO;
import core.tut.pori.http.ResponseData;
import core.tut.pori.users.UserIdentity;
import core.tut.pori.utils.ISODateAdapter;

/**
 * abstract base class for tasks
 * 
 */
@XmlRootElement(name=Definitions.ELEMENT_ABSTRACT_TASK)	//rename xml root element to allow sub-classing
@XmlAccessorType(XmlAccessType.NONE)
public abstract class Task extends ResponseData {
	@XmlJavaTypeAdapter(ISODateAdapter.class)
	@XmlElement(name = Definitions.ELEMENT_CREATED_TIMESTAMP)
	private Date _created = null;
	@XmlElement(name = Definitions.ELEMENT_DESCRIPTION)
	private String _description = null;
	@XmlElement(name = Definitions.ELEMENT_DATA_VISIBILITY)
	private Visibility _dataVisibility = null; // visibility of the data generated by this task
	@XmlElement(name = Definitions.ELEMENT_NAME)
	private String _name = null;
	@XmlElement(name = Definitions.ELEMENT_TASK_STATE)
	private State _state = null;
	@XmlElementWrapper(name = Definitions.ELEMENT_TASK_ID_LIST)
	@XmlElement(name = Definitions.ELEMENT_TASK_ID)
	private List<String> _taskIds = null;
	@XmlElementWrapper(name = Definitions.ELEMENT_TASK_TYPE_LIST)
	@XmlElement(name = Definitions.ELEMENT_TASK_TYPE)
	private Set<String> _taskTypes = null;
	@XmlJavaTypeAdapter(ISODateAdapter.class)
	@XmlElement(name = Definitions.ELEMENT_UPDATED_TIMESTAMP)
	private Date _updated = null;
	@XmlElementRef(type = core.tut.pori.users.UserIdentity.class)
	private UserIdentity _userId = null;
	@XmlElementWrapper(name = service.tut.pori.backends.Definitions.ELEMENT_BACKEND_LIST)
	@XmlElement(name = service.tut.pori.backends.Definitions.ELEMENT_BACKEND)
	private List<TaskBackend> _backends = null;
	
	/**
	 * The global state of this task.
	 * 
	 * 
	 */
	@XmlType(name=Definitions.ELEMENT_TASK_STATE)
	@XmlEnum
	public enum State{
		/** The task is currently active */
		@XmlEnumValue(value = Definitions.TASK_STATE_ACTIVE)
		ACTIVE(0),
		/** The task is currently inactive */
		@XmlEnumValue(value = Definitions.TASK_STATE_INACTIVE)
		INACTIVE(1),
		/** The task has been archived (hidden) */
		@XmlEnumValue(value = Definitions.TASK_STATE_ARCHIVED)
		ARCHIVED(2);
		
		private int _value;
		
		/**
		 * 
		 * @param value
		 */
		private State(int value){
			_value = value;
		}
		
		/**
		 * 
		 * @return the enum as integer
		 */
		public int toInt(){
			return _value;
		}
		
		/**
		 * 
		 * @param state
		 * @return the integer value as Status
		 * @throws IllegalArgumentException on invalid value
		 */
		public static State fromInt(int state) throws IllegalArgumentException {
			for(State s : values()){
				if(s._value == state){
					return s;
				}
			}
			throw new IllegalArgumentException("Invalid value "+state+" for "+State.class.toString());
		}
		
		/**
		 * 
		 * @param state
		 * @return the state string converted to State 
		 * @throws IllegalArgumentException on invalid values
		 */
		public static State fromString(String state) throws IllegalArgumentException {
			for(State s : values()){
				if(s.toString().equalsIgnoreCase(state)){
					return s;
				}
			}
			throw new IllegalArgumentException("Invalid value "+state+" for "+State.class.toString());
		}

		@Override
		public String toString() {
			switch(this) {
				case ACTIVE:
					return Definitions.TASK_STATE_ACTIVE;
				case ARCHIVED:
					return Definitions.TASK_STATE_ARCHIVED;
				case INACTIVE:
					return Definitions.TASK_STATE_INACTIVE;
				default:
					throw new IllegalArgumentException("Unhandeled state: "+name());
			}
		}
	} // enum State
	
	/**
	 * Visibility
	 * 
	 * {@value Visibility#PUBLIC} contains {@value Visibility#LIMITED}, {@value Visibility#LIMITED} contains {@value Visibility#PRIVATE}
	 */
	@XmlType(name=Definitions.ELEMENT_DATA_VISIBILITY)
	@XmlEnum
	public enum Visibility{
		/** content is visible only for the task creator */
		@XmlEnumValue(value = Definitions.VISIBILITY_PRIVATE)
		PRIVATE(0),
		/** content is visible only for a limited set of users, and to the task creator */
		@XmlEnumValue(value = Definitions.VISIBILITY_LIMITED)
		LIMITED(1),
		/** content is visible for all users */
		@XmlEnumValue(value = Definitions.VISIBILITY_PUBLIC)
		PUBLIC(2);
		
		private int _value;
		
		/**
		 * 
		 * @param value
		 */
		private Visibility(int value){
			_value = value;
		}
		
		/**
		 * 
		 * @return the enum as integer
		 */
		public int toInt(){
			return _value;
		}
		
		/**
		 * 
		 * @param visibility
		 * @return the integer value as DataVisibility
		 * @throws IllegalArgumentException on invalid value
		 */
		public static Visibility fromInt(int visibility) throws IllegalArgumentException {
			for(Visibility dv : values()){
				if(dv._value == visibility){
					return dv;
				}
			}
			throw new IllegalArgumentException("Invalid value "+visibility+" for "+Visibility.class.toString());
		}
	} // enum Visibility

	/**
	 * @return the callbackUri or null if there is no need to respond to the task
	 */
	@XmlElement(name = Definitions.ELEMENT_CALLBACK_URI)
	public abstract String getCallbackUri();

	/**
	 * Calling this default implementation does nothing.
	 * 
	 * @param uri
	 */
	protected void setCallbackUri(String uri){
		//this does nothing
	}
	
	/**
	 * @return the taskIds
	 * @see #setTaskIds(List)
	 */
	public List<String> getTaskIds() {
		return _taskIds;
	}

	/**
	 * @param taskIds the taskIds to set
	 * @see #getTaskIds()
	 */
	public void setTaskIds(List<String> taskIds) {
		_taskIds = taskIds;
	}

	/**
	 * @return the identity of the user who created this task or null if the task created by the system (not by a particular user)
	 * @see #setUserId(UserIdentity)
	 */
	public UserIdentity getUserId() {
		return _userId;
	}
	
	/**
	 * 
	 * @param taskId
	 * @see #getTaskIds()
	 */
	public void addTaskId(String taskId) {
		if(_taskIds == null) {
			_taskIds = new ArrayList<>();
		}
		_taskIds.add(taskId);
	}

	/**
	 * @param userId the identity of the user who created this task or null if the task created by the system (not by a particular user)
	 * @see #getUserId()
	 */
	public void setUserId(UserIdentity userId) {
		_userId = userId;
	}

	/**
	 * @return the list of all back ends participating in the execution of this task
	 * @see #setBackends(List)
	 */
	public List<TaskBackend> getBackends() {
		return _backends;
	}

	/**
	 * @param backends the list of all back ends participating in the execution of this task
	 * @see #getBackends()
	 */
	public void setBackends(List<TaskBackend> backends) {
		_backends = backends;
	}

	/**
	 * 
	 * @return the taskDAO implementation used for this task
	 */
	public abstract TaskDAO getTaskDao();

	/**
	 * @return the updated
	 * @see #setUpdated(Date)
	 */
	public Date getUpdated() {
		return _updated;
	}

	/**
	 * @param updated the updated to set
	 * @see #getUpdated()
	 */
	public void setUpdated(Date updated) {
		_updated = updated;
	}

	/**
	 * @return the created
	 * @see #setCreated(Date)
	 */
	public Date getCreated() {
		return _created;
	}

	/**
	 * @param created the created to set
	 * @see #getCreated()
	 */
	public void setCreated(Date created) {
		_created = created;
	}

	/**
	 * @return the taskTypes
	 * @see #setTaskTypes(Set)
	 */
	public Set<String> getTaskTypes() {
		return _taskTypes;
	}

	/**
	 * @param taskTypes the taskTypes to set
	 * @see #getTaskTypes()
	 */
	public void setTaskTypes(Set<String> taskTypes) {
		_taskTypes = taskTypes;
	}

	/**
	 * @return the description
	 * @see #setDescription(String)
	 */
	public String getDescription() {
		return _description;
	}

	/**
	 * @param description the description to set
	 * @see #getDescription()
	 */
	public void setDescription(String description) {
		_description = description;
	}

	/**
	 * @return the name
	 * @see #setName(String)
	 */
	public String getName() {
		return _name;
	}

	/**
	 * @param name the name to set
	 * @see #getName()
	 */
	public void setName(String name) {
		_name = name;
	}

	/**
	 * @return the visibility of the data generated by this task
	 * @see #setDataVisibility(Visibility)
	 */
	public Visibility getDataVisibility() {
		return _dataVisibility;
	}

	/**
	 * @param dataVisibility the dataVisibility to set
	 * @see #getDataVisibility()
	 */
	public void setDataVisibility(Visibility dataVisibility) {
		_dataVisibility = dataVisibility;
	}
	
	/**
	 * @return the state
	 * @see #setState(State)
	 */
	public State getState() {
		return _state;
	}

	/**
	 * @param state the state to set
	 * @see #getState()
	 */
	public void setState(State state) {
		_state = state;
	}

	/**
	 * For a basic implementation of builder that sends the tasks to the given back ends, you can use {@link service.tut.pori.tasks.BackendTaskJob#getBuilder(service.tut.pori.tasks.datatypes.Task)} for the builder initialization.
	 * 
	 * @return job builder
	 */
	public abstract JobBuilder getBuilder();
	
	/**
	 * copy constructor for creating a shallow copy of the given object
	 * 
	 * @param task
	 */
	public Task(Task task) {
		super();
		_created = task._created;
		_description = task._description;
		_name = task._name;
		_taskIds = task._taskIds;
		_taskTypes = task._taskTypes;
		_updated = task._updated;
		_userId = task._userId;
		_backends = task._backends;
		_dataVisibility = task._dataVisibility;
		_state = task._state;
	}
	
	/**
	 * 
	 */
	public Task() {
		super();
	}

	/**
	 * for sub-classing, use the static
	 * 
	 * @return true if the task is valid (has at least one back end defined, and the data visibility is set)
	 * @see #isValid(Task)
	 */
	protected boolean isValid(){
		if(_backends == null || _backends.isEmpty()){
			return false;
		}
		
		for(TaskBackend backend : _backends){
			if(!TaskBackend.isValid(backend)){
				return false;
			}
		}

		return true;
	}
	
	/**
	 * 
	 * @param task
	 * @return true if the task is not-null and valid
	 */
	public static boolean isValid(Task task){
		if(task == null){
			return false;
		}else{
			return task.isValid();
		}
	}
}
